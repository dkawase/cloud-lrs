/**
* Copyright Â©2016. The Regents of the University of California (Regents). All Rights Reserved.
*
* Permission to use, copy, modify, and distribute this software and its documentation
* for educational, research, and not-for-profit purposes, without fee and without a
* signed licensing agreement, is hereby granted, provided that the above copyright
* notice, this paragraph and the following two paragraphs appear in all copies,
* modifications, and distributions.
*
* Contact The Office of Technology Licensing, UC Berkeley, 2150 Shattuck Avenue,
* Suite 510, Berkeley, CA 94720-1620, (510) 643-7201, otl@berkeley.edu,
* http://ipira.berkeley.edu/industry-info for commercial licensing opportunities.
*
* IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT, SPECIAL,
* INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING OUT OF
* THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS BEEN ADVISED
* OF THE POSSIBILITY OF SUCH DAMAGE.
*
* REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
* SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED HEREUNDER IS PROVIDED
* "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
* ENHANCEMENTS, OR MODIFICATIONS.
*/

var _ = require('lodash');
var joi = require('joi');
var uuid = require('uuid');
var config = require('config');

var DB = require('lrs-core/lib/db');
var log = require('lrs-core/lib/logger')('lrs-statements');
var CaliperValidator = require('caliperjs/src/validator');

const CALIPER = 'CALIPER';

/**
* Get a learning activity statement by its uuid
*
* @param  {String}           id                    The uuid by which to retrieve the learning activity statement
* @param  {Function}         callback              Standard callback function
* @param  {Object}           callback.err          An error that occurred, if any
* @param  {Statement}        callback.statement    The requested learning activity statement
*/
var getStatement = module.exports.getStatement = function(id, callback) {
  // Parameter validation
  var validationSchema = joi.object().keys({
    'id': joi.string().required()
  });

  var validationResult = joi.validate({
    'id': id
  }, validationSchema);

  if (validationResult.error) {
    return callback({'code': 400, 'msg': validationResult.error.details[0].message});
  }

  DB.Statement.findById(id).complete(function(err, statement) {
    if (err) {
      log.error({'err': err, 'id': id}, 'An error occurred when getting a learning activity statement');
      return callback({'code': 500, 'msg': err.message});
    } else if (!statement) {
      return callback({'code': 404, 'msg': 'Could not find a learning activity statement'});
    }

    return callback(null, statement);
  });
};



/**
* Validate and save a learning activity statement
*
* @param  {Object}           ctx                       Context containing write credentials
* @param  {Object}           statement                 The learning activity statement to save
* @param  {Function}         callback                  Standard callback function
* @param  {Object}           callback.err              An error that occurred, if any
*/
var saveStatement = module.exports.saveStatement = function(ctx, statement, callback) {
  if (!ctx || !ctx.auth) {
    log.error({'err': err}, 'Prevented storing a learning activity without authentication');
    return callback({'code': 500, 'msg': 'Prevented storing a learning activity without authentication'});
  }

  if (statement.uuid) {
    getStatement(statement.uuid, function(err, retrievedStatement) {
      if (retrievedStatement) {
        log.error({'id': statement.uuid}, 'Attempted to save a learning activity statement that already exists');
        return callback({'code': 400, 'msg': 'Attempted to save a learning activity statement that already exists'});
      } else if (err && err.code !== 404) {
        log.error({'id': statement.uuid}, 'Unable to verify if learning activity statement already exists');
        return callback(err);
      }

      validateStatement(statement, function(err, statement) {
        if (err) {
          log.error({'err': err}, 'The caliper statment had validation errors. Sad!');
          return callback(err);
        }
        log.info('The Caliper statement passed basic valid for now!! Extreme vetting needed');

        var currentTimestamp = new Date().toISOString();

        // When no timestamp has been included, generate one
        statement.eventTime = statement.eventTime || currentTimestamp;

        // Get the user associated to this learning activity. If the user
        // doesn't exist yet, it will be created
        getOrCreateUser(ctx, statement, function(err, user) {
          if (err) {
            log.error({'err': err}, 'An error occured while getting the learning activity statement actor');
            return callback(err);
          }

          log.debug("User retrieved : " + JSON.stringify(user));

          // Store the learning activity statement in the DB
          var storedStatement = {
            'uuid': statement.uuid,
            'statement': statement,
            'verb': statement.type.toString(),
            'timestamp': statement.eventTime,
            'activity_type': statement.action.toString(),
            'voided': false,
            'tenant_id': ctx.auth.tenant_id,
            'user_id': user.id,
            'actor_type': statement.actor.type.toString(),
            'statement_type': CALIPER,
            'write_credential_id': ctx.auth.id
          };

          DB.Statement.create(storedStatement).complete(function(err, statement) {
            if (err) {
              log.error({'err': err}, 'Failed to store a new learning activity statement');
              return callback({'code': 500, 'msg': err.message});
            }
            log.info({'statement_id': statement.uuid}, 'Successfully stored learning activity statement');
            return callback(null, statement);
          });

        });
      });
    });
  }
};


/**
* Retrieve the user that corresponds to the actor on a learning activity statement.
* If the user doesn't exist, it will be created.
*
* @param  {Object}           ctx                       Context containing write credentials
* @param  {Object}           statement                 The learning activity statement to extract the actor from
* @param  {Function}         callback                  Standard callback function
* @param  {Object}           callback.err              An error that occurred, if any
* @param  {Object}           callback.user             The requested user, or the generated user if the user didn't exist
* @api private
*/
var getOrCreateUser = function(ctx, statement, callback) {

  // Extract the user's name & id from the actor object
  // TODO : The RegEx used here holds good for UCB. If there is any other tenant then the parsing should be done properly to extract the correct
  // user id. Revisit it when supporting multiple tenants.

  var name = null;
  var userIdRegExp = new RegExp('[UID:0-9]+$');

  // Extract the user's external id & name if available.
  // TODO : Check if there is name forwarded as a part of Caliper payload
  // TODO : Add support for other actor types like Software Application, Organizations etc.
  var external_id = null;

  // Extract user information if actor type is Person or SoftwareApplication
  if (statement.actor.hasOwnProperty('type') && statement.actor.hasOwnProperty('id') && statement.actor.type == 'Person') {
    log.info("External_ID for the user is : " + userIdRegExp.exec(statement.actor.id));
    external_id = userIdRegExp.exec(statement.actor.id).toString();
  } else if (statement.actor.type == 'SoftwareApplication') {

    if (statement.object.actor.hasOwnProperty('type') && statement.object.actor.hasOwnProperty('id') && statement.object.actor.type == 'Person') {
      log.info("External_ID for the user is : " + userIdRegExp.exec(statement.object.actor.id));
      external_id = userIdRegExp.exec(statement.object.actor.id).toString();
    }
  }

  if (!external_id) {
    log.info({'statement': statement}, 'Unable to extract user from statement');
    return callback({'code': 500, 'msg': 'Unable to extract user from statement'});
  }

  // Get the user from the DB or create it if it doesn't exist yet
  options = {
    'where': {
      'tenant_id': ctx.auth.tenant_id,
      'external_id': external_id
    },
    'defaults': {
      'tenant_id': ctx.auth.tenant_id,
      'external_id': external_id,
      'name': name
    }
  };

  DB.User.findOrCreate(options).complete(function(err, data) {
    if (err) {
      log.error({'err': err}, 'Failed to get or create a user');
      return callback({'code': 500, 'msg': err.message});
    }

    var user = data[0];
    return callback(null, user);
  });
};


/**
* Check required Event properties against set of user-supplied values
* @param statement
* @returns {*}
*/
var validateStatement = module.exports.validateStatement = function(statement, callback) {
  var validationError = '';
  Object.keys(statement).forEach(function(key) {
    switch (key) {
      case "@context":
      if (!CaliperValidator.hasCaliperContext(statement)) {
        validationError = validationError + "\nRequired context not provided.";
      }
      break;
      case "type":
      if (!CaliperValidator.hasType(statement)) {
        validationError = validationError + "\nRequired type not provided.";
      }
      break;
      case "uuid":
      if (!CaliperValidator.hasUUID(statement)) {
        statement.uuid = uuid.v4();
      }
      break;
      case "actor":
      if (!CaliperValidator.hasActor(statement)) {
        validationError = validationError + "\nRequired actor not provided.";
      }
      break;
      case "action":
      if (!CaliperValidator.hasAction(statement)) {
        validationError = validationError + "\nRequired action not provided.";
      }
      break;
      case "object":
      if (!CaliperValidator.hasObject(statement)) {
        validationError = validationError + "\nRequired object not provided.";
      }
      break;
      case "eventTime":
      if (!CaliperValidator.hasEventTime(statement)) {
        validationError = validationError + "\nRequired ISO 8601 formatted eventTime not provided.";
      }
      break;
    }
  });

  if (validationError) {
    log.error("Validation errors found in Caliper statement");
    return callback({'code': 400, 'msg': validationError});
  } else {
    log.info("Caliper statement passed basic validation");
    return callback(null, statement);
  }
};
